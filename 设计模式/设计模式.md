# 设计模式

by HyperQing 20170511

>示例代码以 PHP 语言书写。

## 一些原则

### 单一职责原则

术语：单一职责原则，就一个类而言，应该仅有一个引起它变化的原因。

一句话描述：一个类管好自己做的事，别什么都堆在一个类里做。

例如：业务流程和显示就可以分成两个类。常见的有：网站MVC框架等。

### 开放-封闭原则

术语：开放-封闭原则，是说软件实体（类、模块、函数等）应该可以扩展，但是不可修改。

一句话描述：对于可能会频繁修改的需求，应该通过添加新代码来实现，而不是修改旧代码。

例如：代码充斥着如同排比一样else来做业务分支，加业务就加else的，是时候该换成添加类了。

### 依赖倒转原则

术语：
A、高层模块不应该依赖低层模块。两个都应该依赖抽象。
B、抽象不应该依赖细节。细节应该依赖抽象。

一句话描述：面向接口编程。

例如：业务类使用了某基础服务类，当要重用业务类或更换基础服务类时，由于两者的结合调用时写死在代码里，想把其中一个类分离出来就相当困难了。如果业务类通过自己写的一个基础服务接口来调用基础服务，此时基础服务你爱怎么换就怎么换，而业务类重用时也不用过多考虑基础服务类的调用情况。

### 里氏代换原则

术语：子类型必须能够代替掉它们的父类型。

一句话描述：自己写个接口类，统一各种子类的使用方法，这个此时实例化子类时，爱换哪个换哪个，因为接口和用法都一样。

例如：自己写个缓存类时，可能同时有文件缓存类、MySQL缓存类、Redis缓存类，为了让这些类方便随时替换，这些类都实现同样的“缓存接口”，如“读方法”，“写方法”等，而且这些方法的用法是一样的。

下方示例代码最后实例化语句中，由于PHP是弱类型语言，故没有类型声明。在强类型语言中，应该声明为`CacheDriver`类型，使得`cache`变量可以兼容实现同一接口的子类。如果要替换缓存类型，直接修改`CacheFactory`的`getInstance`方法即可，或按自己需求实现实例化方法（如读取配置来确认实例化何种类型的缓存）。

```php
interface CacheDriver
{
    public function save();

    public function load();
}

class MysqlCache implements CacheDriver
{

    public function save()
    {
        // 写入缓存
    }

    public function load()
    {
        // 读取缓存
    }
}

class RedisCache implements CacheDriver
{

    public function save()
    {
        // 写入缓存
    }

    public function load()
    {
        // 读取缓存
    }
}

class CacheFactory
{
    public static function getInstanse()
    {
        return new RedisCache;
    }
}

$cache = CacheFactory::getInstanse();
```

## 简单工厂模式

一句话描述：该工厂类提供一个静态方法，通过给该方法传参得到具体的实例对象。（实例化什么、如何实例化看需求。）

说明：如果有大量`if`,`switch`的场合，为了避免误改其他代码，应使用这种模式实现，只需添加类或修改某个类即可，无需触碰其他类代码。

```php
// 若干个业务类
class A{}
class B{}
class C{}

// 简单工厂类
class SimpleFactory
{
    public static function getInstance($operation)
    {
        switch ($operation) {
            case 'a':
                return new A;
            case 'b':
                return new B;
            case 'c':
                return new C;
        }
        return null;
    }
}

$class_a = SimpleFactory::getInstance('a');
$class_b = SimpleFactory::getInstance('b');
$class_c = SimpleFactory::getInstance('c');
```

## 策略模式

用一个上下文类来
说明：
